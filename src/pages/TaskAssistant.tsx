import { aiConversationApi } from '@/api/ai'
import AIModeSelector from '@/components/AIModeSelector'
import BackToDashboardButton from '@/components/BackToDashboardButton'
import SmartAIConfig from '@/components/SmartAIConfig'
import SmartPrompts from '@/components/SmartPrompts'
import StreamingMessage from '@/components/streaming/StreamingMessage'
import VersionSwitcher from '@/components/VersionSwitcher'
import { useAI } from '@/hooks/useAI'
import { useAIStream } from '@/hooks/useAIStream'
import { useTasks } from '@/hooks/useTasks'
import { useVersionMode } from '@/hooks/useVersionMode'
import { AIAssistantConfig, EnhancedAIConfig, Task } from '@/types'
import { formatDateTime } from '@/utils'
import { LucideBot, LucideChevronDown, LucideLightbulb, LucideMessageSquare, LucidePlus, LucideRefreshCw, LucideSend, LucideSettings, LucideSquare, LucideTrash2, LucideUser } from 'lucide-react'
import { useCallback, useEffect, useRef, useState } from 'react'
import SubscriptionStatus from '../components/SubscriptionStatus'
import styles from './TaskAssistant.module.css'

const TaskAssistant = () => {
  // Initialize version mode management
  const versionMode = useVersionMode(13) // Default to college freshman

  const {
    conversations,
    currentConversation,
    messages,
    loading: classicLoading,
    error: classicError,
    aiConfig,
    fetchConversations,
    createConversation,
    selectConversation,
    deleteConversation,
    deleteAllConversations,
    sendMessageFast,
    updateAIConfig,
    getAIModeOptions,
    getCurrentConfigDescription,
    clearError,
    forceResetLoading,
    addMessage
  } = useAI()

  const {
    isStreaming,
    streamingMessage,
    sendStreamMessage,
    stopStreaming,
    error: streamError,
    clearError: clearStreamError,
    clearStreamingMessage
  } = useAIStream()

  const { tasks, fetchTasks } = useTasks()
  const [selectedTask, setSelectedTask] = useState<Task | null>(null)
  const [inputMessage, setInputMessage] = useState('')
  const [showConfig, setShowConfig] = useState(false)
  const [showTaskSelector, setShowTaskSelector] = useState(false)
  const [showQuickPrompts, setShowQuickPrompts] = useState(false)
  const [useStreamMode, setUseStreamMode] = useState(false)
  const [showVersionSelector, setShowVersionSelector] = useState(false)
  const [showModeSelector, setShowModeSelector] = useState(false)
  
  // Enhanced AI Configuration State - ‰ΩøÁî®ÈªòËÆ§ÂÄºÈÅøÂÖçÂæ™ÁéØ‰æùËµñ
  const [enhancedConfig, setEnhancedConfig] = useState<EnhancedAIConfig>({
    auto_adjust_difficulty: true,
    adaptive_language: true,
    academic_level_config: {
      high_school: {
        max_complexity: 'intermediate',
        preferred_explanation_style: 'step_by_step',
        vocabulary_level: 'grade_appropriate'
      },
      college: {
        max_complexity: 'advanced',
        preferred_explanation_style: 'analytical',
        vocabulary_level: 'academic'
      }
    },
    mode_specific_config: {
      response_length: 'detailed',
      interaction_style: 'conversational',
      feedback_frequency: 'moderate'
    },
    writing_style: 'academic',
    citation_format: 'apa',
    difficulty_level: 'intermediate',
    model: 'gpt-3.5-turbo'
  })
  
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLTextAreaElement>(null)

  const configDropdownRef = useRef<HTMLDivElement>(null)
  const promptsDropdownRef = useRef<HTMLDivElement>(null)
  const versionDropdownRef = useRef<HTMLDivElement>(null)
  const modeDropdownRef = useRef<HTMLDivElement>(null)

  const loading = useStreamMode ? isStreaming : classicLoading
  const error = useStreamMode ? streamError : classicError

  // ÂàùÂßãÂåñenhancedConfig‰∏éaiConfigÂêåÊ≠• - Âè™Âú®ÂàùÂßãÂåñÊó∂ÂêåÊ≠•‰∏ÄÊ¨°
  useEffect(() => {
    setEnhancedConfig(prev => ({
      ...prev,
      writing_style: aiConfig.writing_style || prev.writing_style,
      citation_format: aiConfig.citation_format || prev.citation_format,
      difficulty_level: aiConfig.difficulty_level || prev.difficulty_level,
      model: aiConfig.model || prev.model
    }))
  }, []) // Á©∫‰æùËµñÊï∞ÁªÑÔºåÂè™Âú®ÁªÑ‰ª∂ÊåÇËΩΩÊó∂ÊâßË°å‰∏ÄÊ¨°

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (configDropdownRef.current && !configDropdownRef.current.contains(event.target as Node)) {
        setShowConfig(false)
      }
      if (promptsDropdownRef.current && !promptsDropdownRef.current.contains(event.target as Node)) {
        setShowQuickPrompts(false)
      }
      if (versionDropdownRef.current && !versionDropdownRef.current.contains(event.target as Node)) {
        setShowVersionSelector(false)
      }
      if (modeDropdownRef.current && !modeDropdownRef.current.contains(event.target as Node)) {
        setShowModeSelector(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [])

  // Ëá™Âä®ÊªöÂä®Âà∞ÊúÄÊñ∞Ê∂àÊÅØ
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])

  // Âä†ËΩΩ‰ªªÂä°Êï∞ÊçÆ
  useEffect(() => {
    fetchTasks()
  }, [fetchTasks])

  // Â§ÑÁêÜÂèëÈÄÅÊ∂àÊÅØÔºàÊîØÊåÅÊµÅÂºèÂíåÈùûÊµÅÂºèÊ®°ÂºèÔºâ
  const handleSendMessage = useCallback(async () => {
    if (!inputMessage.trim() || loading) return

    const message = inputMessage.trim()
    
    // üöÄ ÊÄßËÉΩ‰ºòÂåñÔºöÁ´ãÂç≥Ê∏ÖÁ©∫ËæìÂÖ•Ê°ÜÂíåÊòæÁ§∫Áî®Êà∑Ê∂àÊÅØÔºåÁªôÁî®Êà∑Âç≥Êó∂ÂèçÈ¶à
    setInputMessage('')

    // Á°ÆÂÆöË¶Å‰ΩøÁî®ÁöÑÂØπËØù
    let conversationToUse = currentConversation

    // Â¶ÇÊûúÊ≤°ÊúâÂΩìÂâçÂØπËØùÔºåÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑ
    if (!conversationToUse) {
      // Ê†πÊçÆÈÄâ‰∏≠ÁöÑ‰ªªÂä°Á±ªÂûãÁ°ÆÂÆöassistant_type
      const assistantType = selectedTask?.type === 'writing' ? 'writing' :
                           selectedTask?.type === 'assignment' || selectedTask?.type === 'exam' || selectedTask?.type === 'quiz' ? 'stem' :
                           selectedTask?.type === 'reading' ? 'reading' : 'programming'
      
      const newConversation = await createConversation(assistantType, selectedTask?.id)
      if (!newConversation) {
        // Â¶ÇÊûúÂàõÂª∫ÂØπËØùÂ§±Ë¥•ÔºåÊÅ¢Â§çËæìÂÖ•Ê°ÜÂÜÖÂÆπ
        setInputMessage(message)
        return
      }
      
      conversationToUse = newConversation
    }

    // üöÄ Á´ãÂç≥Ê∑ªÂä†Áî®Êà∑Ê∂àÊÅØÂà∞ÁïåÈù¢ÔºåÊó†ÈúÄÁ≠âÂæÖ‰ªª‰ΩïÁΩëÁªúÊìç‰Ωú
    const userMessage = {
      id: `user_${Date.now()}`,
      conversation_id: conversationToUse.id,
      role: 'user' as const,
      content: message,
      timestamp: new Date().toISOString()
    }
    addMessage(userMessage)
    console.log('‚ö° Áî®Êà∑Ê∂àÊÅØÂ∑≤Á´ãÂç≥ÊòæÁ§∫')

    if (useStreamMode && conversationToUse) {
      // ‰ΩøÁî®‰ºòÂåñÂêéÁöÑÊµÅÂºèÂìçÂ∫î - AIË∞ÉÁî®Âá†‰πéÁ´ãÂç≥ÂºÄÂßã
      try {
        await sendStreamMessage(message, conversationToUse, aiConfig, async (fullContent: string) => {
          // ÊµÅÂºèÂÆåÊàêÂêéÁõ¥Êé•Ê∑ªÂä†Âà∞Ê∂àÊÅØÂàóË°®
          console.log('‚úÖ ÊµÅÂºèÂìçÂ∫îÂÆåÊàêÔºåÊ∑ªÂä†AIÊ∂àÊÅØ')
          
          const newAIMessage = {
            id: `ai_${Date.now()}`,
            conversation_id: conversationToUse.id,
            role: 'assistant' as const,
            content: fullContent,
            timestamp: new Date().toISOString()
          }
          
          addMessage(newAIMessage)
          clearStreamingMessage()
          console.log('üéâ ÂØπËØùÊµÅÁ®ãÂÆåÊàê')
        })
      } catch (error) {
        console.error('‚ùå ÊµÅÂºèÊ∂àÊÅØÂèëÈÄÅÂ§±Ë¥•:', error)
        // ÂèØ‰ª•ÈÄâÊã©ÊòØÂê¶ÁßªÈô§Â∑≤ÊòæÁ§∫ÁöÑÁî®Êà∑Ê∂àÊÅØÊàñÊòæÁ§∫ÈîôËØØÁä∂ÊÄÅ
      }
    } else {
      // ‰ΩøÁî®‰ºòÂåñÁöÑÊôÆÈÄöÊ®°ÂºèÔºàÈùûÊµÅÂºèÔºâ
      try {
        console.log('üîÑ ÂºÄÂßãÊôÆÈÄöÊ®°ÂºèAIÂØπËØù')
        await sendMessageFast(message, conversationToUse, userMessage)
        console.log('‚úÖ ÊôÆÈÄöAIÂìçÂ∫îÂÆåÊàê')
      } catch (error) {
        console.error('‚ùå ÊôÆÈÄöÊ∂àÊÅØÂèëÈÄÅÂ§±Ë¥•:', error)
        setInputMessage(message) // ÊÅ¢Â§çËæìÂÖ•ÂÜÖÂÆπ
        // ÂèØ‰ª•ÈÄâÊã©ÁßªÈô§Áî®Êà∑Ê∂àÊÅØÊàñÊòæÁ§∫ÈîôËØØÁä∂ÊÄÅ
      }
    }
  }, [inputMessage, loading, currentConversation, createConversation, selectedTask, useStreamMode, sendStreamMessage, sendMessageFast, aiConfig, addMessage, clearStreamingMessage])

  // Â§ÑÁêÜÂø´ÈÄüÊèêÁ§∫ÈÄâÊã©
  const handleQuickPromptSelect = useCallback((prompt: string) => {
    setInputMessage(prompt)
    setShowQuickPrompts(false)
    // ËÅöÁÑ¶Âà∞ËæìÂÖ•Ê°Ü
    setTimeout(() => {
      inputRef.current?.focus()
    }, 100)
  }, [])

  // Â§ÑÁêÜÂõûËΩ¶ÂèëÈÄÅ
  const handleKeyPress = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSendMessage()
    }
  }, [handleSendMessage])

  // ÂàõÂª∫Êñ∞ÂØπËØù
  const handleNewConversation = useCallback(async () => {
    const assistantType = selectedTask?.type === 'writing' ? 'writing' :
                         selectedTask?.type === 'assignment' ? 'stem' :
                         selectedTask?.type === 'reading' ? 'reading' : 'programming'
    
    await createConversation(assistantType, selectedTask?.id)
  }, [createConversation, selectedTask])

  // Êõ¥Êñ∞AIÈÖçÁΩÆ
  const handleConfigChange = useCallback((config: Partial<AIAssistantConfig>) => {
    updateAIConfig(config)
  }, [updateAIConfig])

  // Ê∏ÖÈô§ÈîôËØØÔºàÂêåÊó∂Ê∏ÖÈô§‰∏§ÁßçÊ®°ÂºèÁöÑÈîôËØØÔºâ
  const handleClearError = useCallback(() => {
    clearError()
    clearStreamError()
    clearStreamingMessage()
  }, [clearError, clearStreamError, clearStreamingMessage])

  // ÂÅúÊ≠¢ÊµÅÂºèÂìçÂ∫î
  const handleStopStreaming = useCallback(() => {
    stopStreaming()
  }, [stopStreaming])

  // Âà†Èô§ÂØπËØù - ‰ºòÂåñÁâàÊú¨ÔºåÊõ¥ÊµÅÁïÖÁöÑ‰ΩìÈ™å
  const handleDeleteConversation = useCallback(async (conversationId: string, e: React.MouseEvent) => {
    e.preventDefault()
    e.stopPropagation() // Èò≤Ê≠¢Ëß¶ÂèëÈÄâÊã©ÂØπËØù
    
    try {
      const result = await deleteConversation(conversationId)
      if (!result.success && result.error) {
        // Âè™Âú®ÁúüÊ≠£Â§±Ë¥•Êó∂ÊòæÁ§∫ÈîôËØØÔºå‰πêËßÇÊõ¥Êñ∞Â∑≤ÁªèÂ§ÑÁêÜ‰∫ÜUI
        console.error('Failed to delete conversation:', result.error)
      }
    } catch (error) {
      console.error('Failed to delete conversation:', error)
    }
  }, [deleteConversation])

  // Âà†Èô§ÊâÄÊúâÂØπËØù - ‰øùÁïôÁ°ÆËÆ§ÂØπËØùÊ°ÜÔºåÂõ†‰∏∫ËøôÊòØÈáçË¶ÅÊìç‰Ωú
  const handleDeleteAllConversations = useCallback(async () => {
    if (conversations.length === 0) {
      alert('No conversations to delete.')
      return
    }

    if (window.confirm(`Are you sure you want to delete ALL ${conversations.length} conversations? This action cannot be undone.`)) {
      try {
        const result = await deleteAllConversations()
        if (result.success) {
          // ÊàêÂäüÊ∂àÊÅØÊòØÂèØÈÄâÁöÑÔºåÂõ†‰∏∫UIÂ∑≤Áªè‰πêËßÇÊõ¥Êñ∞
          console.log(`Successfully deleted ${result.deletedCount} conversations.`)
        } else {
          console.error('Failed to delete all conversations:', result.error)
          alert('Failed to delete conversations. Please try again.')
        }
      } catch (error) {
        console.error('Failed to delete all conversations:', error)
        alert('Failed to delete conversations. Please try again.')
      }
    }
  }, [deleteAllConversations, conversations.length])

  // Ëé∑Âèñ‰ªªÂä°Á±ªÂûãÂõæÊ†á
  const getTaskTypeIcon = (type: string) => {
    switch (type) {
      case 'writing': return '‚úçÔ∏è'
      case 'reading': return 'üìö'
      case 'assignment': return 'üìù'
      case 'exam': return 'üìä'
      case 'quiz': return '‚ùì'
      case 'project': return 'üéØ'
      case 'presentation': return 'üé§'
      default: return 'üìã'
    }
  }

  // Ëé∑Âèñ‰ªªÂä°Áä∂ÊÄÅÈ¢úËâ≤
  const getTaskStatusColor = (status: string) => {
    switch (status) {
      case 'completed': return '#10b981'
      case 'in_progress': return '#f59e0b'
      case 'overdue': return '#ef4444'
      default: return '#6b7280'
    }
  }

  // Ê®°ÊãüÁî®Êà∑ËÆ¢ÈòÖÁä∂ÊÄÅ
  const [userSubscription] = useState({
    plan: 'free' as const,
    usageStats: {
      monthly_conversations_used: 15,
      monthly_courses_used: 2,
      monthly_conversations_limit: 50,
      monthly_courses_limit: 5
    }
  })

  // üöÄ Ëé∑ÂèñÊ∂àÊÅØÁöÑÂÆåÊï¥ÂÜÖÂÆπ
  const getMessageFullContent = useCallback(async (messageId: string) => {
    try {
      const response = await aiConversationApi.getMessageFullContent(messageId)
      if (!response.error && response.data) {
        // Êõ¥Êñ∞Ê∂àÊÅØÂàóË°®‰∏≠ÁöÑËØ•Ê∂àÊÅØ - ÈÄöËøáÈáçÊñ∞Ëé∑ÂèñÂØπËØùÊ∂àÊÅØ
        if (currentConversation) {
          await selectConversation(currentConversation.id)
        }
        
        console.log('‚úÖ ÂÆåÊï¥ÂÜÖÂÆπÂ∑≤Âä†ËΩΩ:', messageId)
      }
    } catch (err: any) {
      console.error('‚ùå Ëé∑ÂèñÂÆåÊï¥ÂÜÖÂÆπÂ§±Ë¥•:', err)
      // ‰ΩøÁî®Ê≠£Á°ÆÁöÑÈîôËØØÂ§ÑÁêÜÊñπÂºèÔºåÊàñËÄÖÂèØ‰ª•ÊòæÁ§∫‰∏Ä‰∏™toastÈÄöÁü•
      console.warn(`Ëé∑ÂèñÂÆåÊï¥ÂÜÖÂÆπÂ§±Ë¥•: ${err.message}`)
    }
  }, [currentConversation, selectConversation])

  return (
    <div className={styles.assistant}>
      <div className={styles.header}>
        {/* È°∂Â±ÇÂØºËà™ */}
        <div className={styles.topNav}>
          <div className={styles.headerContent}>
            <h1>AI Learning Assistant</h1>
            <p>Your personalized tutor for every subject</p>
          </div>
          <div className={styles.navActions}>
            <BackToDashboardButton />
          </div>
        </div>

        {/* Â∫ïÂ±ÇÂ∑•ÂÖ∑Ê†è */}
        <div className={styles.toolbar}>
          <div className={styles.toolbarLeft}>
            {/* Stream/NormalÊ®°ÂºèÂàáÊç¢ */}
            <div className={styles.streamModeToggle}>
              <label className={styles.toggleLabel}>
                <input
                  type="checkbox"
                  checked={useStreamMode}
                  onChange={(e) => setUseStreamMode(e.target.checked)}
                  className={styles.toggleInput}
                />
                <span className={styles.toggleSlider}></span>
                <span className={styles.toggleText}>üöÄ Stream Mode</span>
              </label>
            </div>
          </div>

          <div className={styles.toolbarCenter}>
            {/* ÈîôËØØÊèêÁ§∫ */}
            {error && (
              <div className={styles.errorMessage}>
                <span>‚ö†Ô∏è {error}</span>
                <button onClick={handleClearError} className={styles.clearErrorBtn}>
                  ‚úï
                </button>
              </div>
            )}
          </div>

          <div className={styles.toolbarRight}>
            {/* AI Config Dropdown */}
            <div className={styles.dropdown} ref={configDropdownRef}>
              <button 
                className={`${styles.toolbarBtn} ${showConfig ? styles.active : ''}`}
                onClick={() => {
                  setShowConfig(!showConfig)
                  setShowQuickPrompts(false)
                }}
              >
                <LucideSettings size={18} />
                <span>Config</span>
                <LucideChevronDown size={14} className={`${styles.chevron} ${showConfig ? styles.chevronUp : ''}`} />
              </button>
              {showConfig && (
                <div className={styles.dropdownContent}>
                  <SmartAIConfig
                    currentMode={versionMode.selectedModeId || 'study_buddy'}
                    onConfigChange={(configUpdate) => {
                      setEnhancedConfig(prev => ({ ...prev, ...configUpdate }))
                      // Also update legacy aiConfig for backward compatibility
                      const legacyUpdate: Partial<AIAssistantConfig> = {}
                      if (configUpdate.writing_style) {
                        legacyUpdate.writing_style = configUpdate.writing_style
                      }
                      if (configUpdate.citation_format) {
                        legacyUpdate.citation_format = configUpdate.citation_format
                      }
                      if (configUpdate.difficulty_level) {
                        legacyUpdate.difficulty_level = configUpdate.difficulty_level
                      }
                      if (configUpdate.model) {
                        legacyUpdate.model = configUpdate.model
                      }
                      
                      // Âè™Âú®ÊúâÊõ¥Êñ∞Êó∂ÊâçË∞ÉÁî®
                      if (Object.keys(legacyUpdate).length > 0) {
                        handleConfigChange(legacyUpdate)
                      }
                    }}
                    currentConfig={enhancedConfig}
                  />
                </div>
              )}
            </div>

            {/* Quick Prompts Dropdown */}
            <div className={styles.dropdown} ref={promptsDropdownRef}>
              <button 
                className={`${styles.toolbarBtn} ${styles.quickPromptsBtn} ${showQuickPrompts ? styles.active : ''}`}
                onClick={() => {
                  setShowQuickPrompts(!showQuickPrompts)
                  setShowConfig(false)
                }}
              >
                <LucideLightbulb size={18} />
                <span>Prompts</span>
                <LucideChevronDown size={14} className={`${styles.chevron} ${showQuickPrompts ? styles.chevronUp : ''}`} />
              </button>
              {showQuickPrompts && (
                <div className={styles.dropdownContent}>
                  <SmartPrompts 
                    currentMode={versionMode.selectedModeId || 'study_buddy'}
                    onSelectPrompt={handleQuickPromptSelect}
                    disabled={loading}
                  />
                </div>
              )}
            </div>

            <button 
              className={styles.newChatBtn}
              onClick={handleNewConversation}
              disabled={loading}
              title="ÂºÄÂßãÊñ∞ÂØπËØù"
            >
              <LucidePlus size={18} />
              <span>New Chat</span>
            </button>
          </div>
        </div>
      </div>

      <div className={styles.assistantContent}>
        {/* Â∑¶‰æßËæπÊ†è */}
        <div className={styles.sidebar}>
          {/* ‰ªªÂä°ÈÄâÊã©Âô® - ‰øùÊåÅÂõ∫ÂÆöÂú®È°∂ÈÉ® */}
          <div className={`${styles.section} ${styles.taskSelectorSection}`}>
            <div className={styles.sectionHeader}>
              <h3>Select Task</h3>
              <button 
                className={styles.toggleBtn}
                onClick={() => setShowTaskSelector(!showTaskSelector)}
              >
                {showTaskSelector ? 'Collapse' : 'Expand'}
              </button>
            </div>
            
            {showTaskSelector && (
              <div className={styles.taskList}>
                {tasks.map((task) => (
                  <div 
                    key={task.id}
                    className={`${styles.taskItem} ${selectedTask?.id === task.id ? styles.selected : ''}`}
                    onClick={() => setSelectedTask(task)}
                  >
                    <div className={styles.taskIcon}>
                      {getTaskTypeIcon(task.type)}
                    </div>
                    <div className={styles.taskInfo}>
                      <div className={styles.taskTitle}>{task.title}</div>
                      <div className={styles.taskMeta}>
                        <span className={styles.taskType}>{task.type}</span>
                        <span className={styles.taskDue}>
                          {formatDateTime(task.due_date)}
                        </span>
                      </div>
                    </div>
                    <div 
                      className={styles.taskStatus}
                      style={{ backgroundColor: getTaskStatusColor(task.status) }}
                    />
                  </div>
                ))}
              </div>
            )}

            {selectedTask && (
              <div className={styles.selectedTaskInfo}>
                <h4>Current Task</h4>
                <div className={styles.taskCard}>
                  <div className={styles.taskCardHeader}>
                    <span className={styles.taskCardIcon}>
                      {getTaskTypeIcon(selectedTask.type)}
                    </span>
                    <span className={styles.taskCardTitle}>{selectedTask.title}</span>
                  </div>
                  <p className={styles.taskCardDesc}>{selectedTask.description}</p>
                  <div className={styles.taskCardMeta}>
                    <span>Due: {formatDateTime(selectedTask.due_date)}</span>
                    <span>Priority: {selectedTask.priority}</span>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* AIÊ®°ÂºèÈÄâÊã© - Ê∑ªÂä†ÊªöÂä®ÂÆπÂô® */}
          <div className={styles.aiModeContainer}>
            <div className={styles.section}>
              {/* Version Switcher */}
              <VersionSwitcher
                currentVersion={versionMode.currentVersion}
                onVersionChange={versionMode.switchVersion}
                userGrade={versionMode.userGrade}
                disabled={loading}
              />

              {/* AI Mode Selector */}
              <AIModeSelector
                availableModes={versionMode.availableModes}
                selectedModeId={versionMode.selectedModeId}
                onModeSelect={versionMode.selectMode}
                academicVersion={versionMode.currentVersion}
                userGrade={versionMode.userGrade}
                disabled={loading}
                showExamples={true}
              />

              {/* Current Configuration Display */}
              <div className={styles.currentConfig}>
                <div className={styles.configTitle}>Current Setup</div>
                <div className={styles.configDetails}>
                  <div className={styles.configItem}>
                    <span className={styles.configLabel}>Version:</span>
                    <span className={styles.configValue}>
                      {versionMode.currentVersion === 'high_school' ? 'High School' : 'College'}
                    </span>
                  </div>
                  {versionMode.userGrade && (
                    <div className={styles.configItem}>
                      <span className={styles.configLabel}>Grade:</span>
                      <span className={styles.configValue}>
                        {versionMode.userGrade <= 12 ? `Grade ${versionMode.userGrade}` : `Year ${versionMode.userGrade - 12}`}
                      </span>
                    </div>
                  )}
                  {versionMode.selectedMode && (
                    <div className={styles.configItem}>
                      <span className={styles.configLabel}>Mode:</span>
                      <span className={styles.configValue}>
                        {versionMode.selectedMode.icon} {versionMode.selectedMode.name}
                      </span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

        </div>

        {/* ‰∏ªËÅäÂ§©Âå∫Âüü */}
        <div className={styles.mainContent}>
          <div className={styles.chatContainer}>
            {/* ËÅäÂ§©Â§¥ÈÉ® */}
            <div className={styles.chatHeader}>
              <div className={styles.chatInfo}>
                <h2>
                  AI Chat
                  <span className={styles.modeBadge}>
                    {useStreamMode ? 'üöÄ STREAM' : 'üìù NORMAL'}
                  </span>
                </h2>
                <p>{getCurrentConfigDescription()}</p>
              </div>
              <div className={styles.modeToggle}>
                <button
                  className={`${styles.modeToggleBtn} ${useStreamMode ? styles.active : ''}`}
                  onClick={() => setUseStreamMode(true)}
                  title="ÊµÅÂºèÂìçÂ∫îÊ®°Âºè - ÂÆûÊó∂ÊâìÂ≠óÊïàÊûú"
                >
                  üöÄ Stream
                </button>
                <button
                  className={`${styles.modeToggleBtn} ${!useStreamMode ? styles.active : ''}`}
                  onClick={() => setUseStreamMode(false)}
                  title="ÊôÆÈÄöÂìçÂ∫îÊ®°Âºè - Áû¨Èó¥ÊòæÁ§∫ÂÆåÊï¥ÂõûÂ§ç"
                >
                  üìù Normal
                </button>
              </div>
              <div className={styles.chatActions}>
                {loading && (
                  <div className={styles.loadingIndicator}>
                    <LucideRefreshCw size={16} className={styles.spinning} />
                    {useStreamMode ? 'AI streaming...' : 'AI thinking...'}
                    {useStreamMode && (
                      <button 
                        onClick={handleStopStreaming}
                        style={{
                          marginLeft: '10px',
                          padding: '4px 8px',
                          background: 'rgba(239, 68, 68, 0.2)',
                          border: '1px solid rgba(239, 68, 68, 0.3)',
                          borderRadius: '4px',
                          color: '#ef4444',
                          fontSize: '12px',
                          cursor: 'pointer',
                          display: 'flex',
                          alignItems: 'center',
                          gap: '4px'
                        }}
                        title="ÂÅúÊ≠¢ÊµÅÂºèÂìçÂ∫î"
                      >
                        <LucideSquare size={12} />
                        Stop
                      </button>
                    )}
                    {!useStreamMode && (
                      <button 
                        onClick={forceResetLoading}
                        style={{
                          marginLeft: '10px',
                          padding: '4px 8px',
                          background: 'rgba(239, 68, 68, 0.2)',
                          border: '1px solid rgba(239, 68, 68, 0.3)',
                          borderRadius: '4px',
                          color: '#ef4444',
                          fontSize: '12px',
                          cursor: 'pointer'
                        }}
                        title="ÈáçÁΩÆAIÁä∂ÊÄÅ"
                      >
                        Reset
                      </button>
                    )}
                  </div>
                )}
              </div>
            </div>

            {/* Ê∂àÊÅØÂàóË°® */}
            <div className={styles.messagesContainer}>
              {messages.length === 0 && !isStreaming ? (
                <div className={styles.emptyState}>
                  <div className={styles.emptyIcon}>
                    <LucideBot size={48} />
                  </div>
                  <h3>Start your AI learning journey</h3>
                  <p>Ask a question or select a task to begin your conversation</p>
                  {useStreamMode && (
                    <div className={styles.streamModeInfo}>
                      <span className={styles.streamIcon}>üöÄ</span>
                      <p>Stream Mode enabled - Experience ChatGPT-like real-time responses!</p>
                    </div>
                  )}
                </div>
              ) : (
                <div className={styles.messagesList}>
                  {messages.map((message) => (
                    <div 
                      key={message.id}
                      className={`${styles.message} ${message.role === 'user' ? styles.userMessage : styles.aiMessage}`}
                    >
                      <div className={styles.messageAvatar}>
                        {message.role === 'user' ? (
                          <LucideUser size={20} />
                        ) : (
                          <LucideBot size={20} />
                        )}
                      </div>
                      <div className={styles.messageContent}>
                        {message.role === 'assistant' ? (
                          // AIÊ∂àÊÅØ‰ΩøÁî®StreamingMessageÁªÑ‰ª∂Â§ÑÁêÜÈ¢ÑËßà
                          <StreamingMessage
                            content={message.content}
                            isComplete={true}
                            onExpandToggle={() => getMessageFullContent(message.id)}
                          />
                        ) : (
                          // Áî®Êà∑Ê∂àÊÅØ‰øùÊåÅÂéüÊ†∑
                          <>
                            <div className={styles.messageText}>
                              {message.content}
                            </div>
                            <div className={styles.messageTime}>
                              {formatDateTime(message.timestamp)}
                            </div>
                          </>
                        )}
                      </div>
                    </div>
                  ))}
                  
                  {/* ÊµÅÂºèÂìçÂ∫îÊ∂àÊÅØ */}
                  {isStreaming && streamingMessage && (
                    <div className={`${styles.message} ${styles.aiMessage} ${styles.streamingMessage}`}>
                      <div className={styles.messageAvatar}>
                        <LucideBot size={20} />
                      </div>
                      <div className={styles.messageContent}>
                        <StreamingMessage
                          content={streamingMessage}
                          isComplete={false}
                        />
                      </div>
                    </div>
                  )}
                  
                  <div ref={messagesEndRef} />
                </div>
              )}
            </div>

            {/* ËæìÂÖ•Âå∫Âüü */}
            <div className={styles.inputContainer}>
              <div className={styles.inputWrapper}>
                <textarea
                  ref={inputRef}
                  value={inputMessage}
                  onChange={(e) => setInputMessage(e.target.value)}
                  onKeyPress={handleKeyPress}
                  placeholder={useStreamMode ? "Experience instant AI responses..." : "Describe your question or need..."}
                  rows={1}
                  disabled={loading}
                  className={styles.messageInput}
                />
                <button 
                  onClick={handleSendMessage}
                  disabled={!inputMessage.trim() || loading}
                  className={styles.sendButton}
                >
                  <LucideSend size={20} />
                </button>
              </div>
              <div className={styles.inputHint}>
                Press Enter to send, Shift + Enter for new line
                {useStreamMode && <span className={styles.streamHint}> ‚Ä¢ üöÄ Stream Mode Active</span>}
              </div>
            </div>
          </div>
        </div>

        {/* Âè≥‰æßÁä∂ÊÄÅÊ†è */}
        <div className={styles.rightSidebar}>
          <SubscriptionStatus 
            currentPlan={userSubscription.plan}
            usageStats={userSubscription.usageStats}
          />
          
          {/* Chat History - ÁßªÂà∞Âè≥‰æß */}
          <div className={`${styles.section} ${styles.chatHistorySection}`}>
            <div className={styles.sectionHeader}>
              <h3>Chat History</h3>
              <div className={styles.chatHistoryActions}>
                <button 
                  className={styles.newChatBtn}
                  onClick={handleNewConversation}
                  title="Start new conversation"
                >
                  <LucidePlus size={16} />
                </button>
                {conversations.length > 0 && (
                  <button 
                    className={styles.deleteAllBtn}
                    onClick={handleDeleteAllConversations}
                    title="Delete all conversations"
                  >
                    <LucideTrash2 size={16} />
                  </button>
                )}
              </div>
            </div>
            <div className={`${styles.conversationList} ${styles.chatHistoryContainer}`}>
              {conversations.length === 0 ? (
                <div className={styles.emptyConversations}>
                  <p>No conversations yet.</p>
                  <p>Start a conversation to begin!</p>
                </div>
              ) : (
                conversations.map((conversation) => (
                  <div 
                    key={conversation.id}
                    className={`${styles.conversationItem} ${currentConversation?.id === conversation.id ? styles.selected : ''}`}
                    onClick={() => selectConversation(conversation.id)}
                  >
                    <div className={styles.conversationIcon}>
                      <LucideMessageSquare size={16} />
                    </div>
                    <div className={styles.conversationInfo}>
                      <span className={styles.conversationType}>
                        {conversation.assistant_type}
                      </span>
                      <span className={styles.conversationTime}>
                        {formatDateTime(conversation.updated_at)}
                      </span>
                    </div>
                    <button
                      className={styles.deleteBtn}
                      onClick={(e) => handleDeleteConversation(conversation.id, e)}
                      title="Delete conversation"
                    >
                      <LucideTrash2 size={14} />
                    </button>
                  </div>
                ))
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

export default TaskAssistant 